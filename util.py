# coding:utf-8

from PIL import Image, ImageDraw
import numpy as np
import tensorflow as tf


def load_data(batch_size, with_label=True):
    data = np.load("data/data.npz")
    train_x = np.concatenate([data["train_x"], data["test_x"]])
    train_y = np.concatenate([data["train_y"], data["test_y"]]).astype(np.int32)
    if with_label:
        train_ds = tf.data.Dataset.from_tensor_slices((train_x, train_y)).shuffle(21000).batch(batch_size)
    else:
        train_ds = tf.data.Dataset.from_tensor_slices(train_x).shuffle(21000).batch(batch_size)
    return train_ds


def visualize(images, labels=None, label2text=str, height=20, width=20, channel=1, pad=1):
    """
    将多张图片连标签一起放置在一张图片上
    :param images: 多张图片数据，np.ndarry(dtype=np.uint8)
    :param labels: 图片对应标签，np.ndarry(dtype=np.int64)
    :param label2text: 标签转字符串函数
    :param height: 单张图片高度，int
    :param width: 单张图片宽度，int
    :param channel: 图片通道数，int
    :param pad: 图片边距，int
    :return: PIL.Image
    """
    size = len(images)
    num_h = int(np.ceil(np.sqrt(size)))
    num_v = int(np.ceil(size / num_h).astype(np.int))
    image = np.zeros((num_v * height + (num_v + 1) * pad, num_h * width + (num_h + 1) * pad, channel))
    for idx, img in enumerate(images):
        i = idx // num_h
        j = idx % num_v
        image[pad + i * (height + pad):pad + i * (height + pad) + height, pad + j * (width + pad):pad + j * (width + pad) + width, :] = img
    if channel == 1:
        img = Image.fromarray(image.reshape(image.shape[:-1])).convert("RGB")
    else:
        img = Image.fromarray(image)
    if labels is not None:
        assert len(images) == len(labels)
        draw = ImageDraw.Draw(img)
        for idx, label in enumerate(labels):
            i = idx // num_h
            j = idx % num_v
            draw.text((j * (width + pad) + pad, i * (height + pad) + pad), label2text(label), fill=0)
    return img
